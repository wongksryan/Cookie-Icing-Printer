<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cookie Icing Slicer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            color: #333;
            margin-bottom: 8px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 25px;
            font-size: 14px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 30px;
        }

        .canvas-wrapper {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        canvas {
            border: 3px solid #f5576c;
            border-radius: 8px;
            background: white;
            cursor: crosshair;
            display: block;
            width: 100%;
            height: auto;
            max-width: 600px;
        }

        .toolbar {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 16px;
            border: 2px solid #f5576c;
            border-radius: 6px;
            background: white;
            color: #f5576c;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        button:hover {
            background: #f5576c;
            color: white;
            transform: translateY(-2px);
        }

        button.active {
            background: #f5576c;
            color: white;
        }

        button.danger {
            border-color: #e74c3c;
            color: #e74c3c;
        }

        button.danger:hover {
            background: #e74c3c;
            color: white;
        }

        .sidebar {
            background: #fff9fa;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #f5e6e8;
        }

        .sidebar h3 {
            color: #333;
            font-size: 16px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f5576c;
        }

        .grid-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
            font-size: 13px;
        }

        .grid-stat {
            background: white;
            padding: 10px;
            border-radius: 4px;
            border-left: 3px solid #f5576c;
        }

        .grid-stat label {
            display: block;
            color: #999;
            font-size: 11px;
            margin-bottom: 3px;
        }

        .grid-stat value {
            display: block;
            color: #333;
            font-weight: 600;
            font-size: 16px;
        }

        .command-list {
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 12px;
            max-height: 220px;
            overflow-y: auto;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            color: #333;
            line-height: 1.6;
        }

        .command-list.empty {
            color: #999;
            font-style: italic;
            text-align: center;
            padding: 20px 12px;
        }

        .command-item {
            padding: 4px 0;
            border-bottom: 1px solid #f5f5f5;
        }

        .command-item:last-child {
            border-bottom: none;
        }

        .export-section {
            margin-top: 20px;
        }

        .export-box {
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
            max-height: 120px;
            overflow-y: auto;
            font-size: 10px;
            font-family: 'Courier New', monospace;
            color: #333;
            word-break: break-all;
            line-height: 1.3;
        }

        .export-btn {
            width: 100%;
            margin-top: 10px;
            background: #27ae60;
            color: white;
            border-color: #27ae60;
            padding: 10px;
        }

        .export-btn:hover {
            background: #229954;
            border-color: #229954;
        }

        .info-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 12px;
            border-radius: 4px;
            margin-top: 15px;
            font-size: 12px;
            color: #856404;
            line-height: 1.5;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 24px;
            }

            canvas {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üç™ Cookie Icing Slicer</h1>
        <p class="subtitle">Design circular cookie patterns and generate VEX IQ icing commands</p>

        <div class="main-content">
            <div class="canvas-wrapper">
                <canvas id="canvas"></canvas>
                
                <div class="toolbar">
                    <button id="lineBtn" class="active">üìè Line</button>
                    <button id="dotBtn">‚ö´ Dot</button>
                    <button id="arcBtn">üîÑ Arc</button>
                    <button id="undoBtn">‚Ü∂ Undo</button>
                    <button id="clearBtn" class="danger">üóëÔ∏è Clear All</button>
                </div>
            </div>

            <div class="sidebar">
                <h3>Commands</h3>
                <div class="grid-info">
                    <div class="grid-stat">
                        <label>Total Commands</label>
                        <value id="commandCount">0</value>
                    </div>
                    <div class="grid-stat">
                        <label>Grid Size</label>
                        <value>24√ó24</value>
                    </div>
                </div>

                <div class="command-list empty" id="commandList">
                    No commands yet
                </div>

                <div class="export-section">
                    <h3 style="margin-bottom: 10px;">Export Array</h3>
                    <textarea id="exportCode" class="export-box" readonly placeholder="Array will appear here"></textarea>
                    <button class="export-btn" onclick="copyToClipboard()">üìã Copy</button>
                    <button class="export-btn" style="background: #3498db; border-color: #3498db; margin-top: 5px;" onclick="downloadAsText()">‚¨áÔ∏è Download .txt</button>
                </div>

                <div class="info-box">
                    <strong>üé® Drawing Tips:</strong><br>
                    ‚Ä¢ Line: click start, then end<br>
                    ‚Ä¢ Dot: click once<br>
                    ‚Ä¢ Arc: start ‚Üí center ‚Üí end<br>
                    ‚Ä¢ Drag points to move them
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Grid configuration
        const GRID_SIZE = 24;
        const RADIUS = 12;
        let CELL_SIZE = 18;
        let currentTool = 'line';
        let commands = [];
        let isDrawing = false;
        let startPoint = null;
        let arcCenter = null;
        let currentPreview = null;
        let hoveredPoint = null;
        let draggingCommandIndex = null;
        let draggingPointIndex = null;

        function resizeCanvas() {
            const size = GRID_SIZE * CELL_SIZE + 40;
            canvas.width = size;
            canvas.height = size;
            redraw();
        }

        function screenToGrid(x, y) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const gridX = Math.round((x - centerX) / CELL_SIZE) + RADIUS;
            const gridY = Math.round((y - centerY) / CELL_SIZE) + RADIUS;
            return { x: gridX, y: gridY };
        }

        function gridToScreen(gridX, gridY) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const x = (gridX - RADIUS) * CELL_SIZE + centerX;
            const y = (gridY - RADIUS) * CELL_SIZE + centerY;
            return { x, y };
        }

        function isInCircle(gridX, gridY) {
            const dx = gridX - RADIUS;
            const dy = gridY - RADIUS;
            return dx * dx + dy * dy <= RADIUS * RADIUS;
        }

        function drawGrid() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            ctx.strokeStyle = '#f5576c';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, RADIUS * CELL_SIZE, 0, Math.PI * 2);
            ctx.stroke();

            ctx.fillStyle = '#e8e8e8';
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 0.5;

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (isInCircle(i, j)) {
                        const { x, y } = gridToScreen(i, j);
                        
                        if (i < GRID_SIZE - 1 && isInCircle(i + 1, j)) {
                            ctx.beginPath();
                            const { x: x2 } = gridToScreen(i + 1, j);
                            ctx.moveTo(x, y);
                            ctx.lineTo(x2, y);
                            ctx.stroke();
                        }
                        if (j < GRID_SIZE - 1 && isInCircle(i, j + 1)) {
                            ctx.beginPath();
                            const { y: y2 } = gridToScreen(i, j + 1);
                            ctx.moveTo(x, y);
                            ctx.lineTo(x, y2);
                            ctx.stroke();
                        }

                        ctx.fillRect(x - 1.5, y - 1.5, 3, 3);
                    }
                }
            }
        }

        function calculateArcCenter(x1, y1, x2, y2, x3, y3) {
            const ax = x2 - x1, ay = y2 - y1;
            const bx = x3 - x1, by = y3 - y1;
            const d = 2 * (ax * by - ay * bx);
            if (Math.abs(d) < 1e-6) return null;
            const ux = (by * (ax * ax + ay * ay) - ay * (bx * bx + by * by)) / d;
            const uy = (ax * (bx * bx + by * by) - bx * (ax * ax + ay * ay)) / d;
            return { x: x1 + ux, y: y1 + uy };
        }

        function calculateArcRadius(x1, y1, x2, y2, x3, y3) {
            const center = calculateArcCenter(x1, y1, x2, y2, x3, y3);
            if (!center) return null;
            return Math.sqrt((x1 - center.x) ** 2 + (y1 - center.y) ** 2);
        }

        function drawCircularArc(x1, y1, cx, cy, x2, y2, context, width = 2, color = '#f5576c') {
            const radius = calculateArcRadius(x1, y1, cx, cy, x2, y2);
            const center = calculateArcCenter(x1, y1, cx, cy, x2, y2);
            
            if (center && radius) {
                const angle1 = Math.atan2(y1 - center.y, x1 - center.x);
                const angle2 = Math.atan2(y2 - center.y, x2 - center.x);
                
                context.strokeStyle = color;
                context.lineWidth = width;
                context.beginPath();
                context.arc(center.x, center.y, radius, angle1, angle2, false);
                context.stroke();
            }
        }

        function drawCommands() {
            commands.forEach((cmd, index) => {
                drawCommand(cmd, index === commands.length - 1);
            });
        }

        function drawCommand(cmd, highlight = false) {
            const [type, ...args] = cmd;
            
            ctx.lineWidth = highlight ? 3 : 2;
            ctx.fillStyle = highlight ? '#ff6b9d' : '#f5576c';
            ctx.strokeStyle = highlight ? '#ff6b9d' : '#f5576c';

            if (type === 1) {
                const { x: x1, y: y1 } = gridToScreen(args[0], args[1]);
                const { x: x2, y: y2 } = gridToScreen(args[2], args[3]);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                ctx.fillRect(x1 - 3, y1 - 3, 6, 6);
                ctx.fillRect(x2 - 3, y2 - 3, 6, 6);
            } 
            else if (type === 2) {
                const { x, y } = gridToScreen(args[0], args[1]);
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
            } 
            else if (type === 3) {
                const { x: x1, y: y1 } = gridToScreen(args[0], args[1]);
                const { x: cx, y: cy } = gridToScreen(args[2], args[3]);
                const { x: x2, y: y2 } = gridToScreen(args[4], args[5]);
                
                drawCircularArc(x1, y1, cx, cy, x2, y2, ctx, highlight ? 3 : 2, highlight ? '#ff6b9d' : '#f5576c');
                
                ctx.fillStyle = highlight ? '#ff6b9d' : '#f5576c';
                ctx.fillRect(x1 - 3, y1 - 3, 6, 6);
                ctx.fillRect(cx - 3, cy - 3, 6, 6);
                ctx.fillRect(x2 - 3, y2 - 3, 6, 6);
            }
        }

        function drawPreview() {
            if (currentPreview) {
                const [type, ...args] = currentPreview;
                ctx.globalAlpha = 0.5;

                if (type === 1) {
                    const { x: x1, y: y1 } = gridToScreen(args[0], args[1]);
                    const { x: x2, y: y2 } = gridToScreen(args[2], args[3]);
                    ctx.strokeStyle = '#ddd';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                } 
                else if (type === 3) {
                    const { x: x1, y: y1 } = gridToScreen(args[0], args[1]);
                    const { x: cx, y: cy } = gridToScreen(args[2], args[3]);
                    const { x: x2, y: y2 } = gridToScreen(args[4], args[5]);
                    drawCircularArc(x1, y1, cx, cy, x2, y2, ctx, 2, '#ddd');
                }

                ctx.globalAlpha = 1;
            }
        }

        function drawHoveredPoint() {
            if (hoveredPoint && isInCircle(hoveredPoint.x, hoveredPoint.y)) {
                const { x, y } = gridToScreen(hoveredPoint.x, hoveredPoint.y);
                ctx.fillStyle = '#ff6b9d';
                ctx.beginPath();
                ctx.arc(x, y, 7, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function redraw() {
            drawGrid();
            drawCommands();
            drawPreview();
            drawHoveredPoint();
        }

        function findPointAtCoords(gridX, gridY, threshold = 1) {
            for (let cmdIdx = 0; cmdIdx < commands.length; cmdIdx++) {
                const cmd = commands[cmdIdx];
                const [type, ...args] = cmd;
                
                let points = [];
                if (type === 1) {
                    points = [[args[0], args[1]], [args[2], args[3]]];
                } else if (type === 2) {
                    points = [[args[0], args[1]]];
                } else if (type === 3) {
                    points = [[args[0], args[1]], [args[2], args[3]], [args[4], args[5]]];
                }
                
                for (let ptIdx = 0; ptIdx < points.length; ptIdx++) {
                    const [px, py] = points[ptIdx];
                    if (Math.abs(px - gridX) <= threshold && Math.abs(py - gridY) <= threshold) {
                        return { cmdIdx, ptIdx };
                    }
                }
            }
            return null;
        }

        function updateCommandList() {
            const list = document.getElementById('commandList');
            const count = document.getElementById('commandCount');
            
            count.textContent = commands.length;

            if (commands.length === 0) {
                list.className = 'command-list empty';
                list.innerHTML = 'No commands yet';
            } else {
                list.className = 'command-list';
                list.innerHTML = commands.map((cmd, i) => {
                    const typeNames = { 1: 'LINE', 2: 'DOT', 3: 'ARC' };
                    return `<div class="command-item">[${i}] ${typeNames[cmd[0]]}: ${cmd.slice(1).join(', ')}</div>`;
                }).join('');
            }

            updateExport();
        }

        function updateExport() {
            const exportBox = document.getElementById('exportCode');
            if (commands.length === 0) {
                exportBox.value = '';
            } else {
                const flatArray = [];
                commands.forEach(cmd => {
                    flatArray.push(...cmd);
                });
                exportBox.value = '[' + flatArray.join(', ') + ']';
            }
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            const gridCoords = screenToGrid(x, y);

            if (!isInCircle(gridCoords.x, gridCoords.y)) return;

            const pointAt = findPointAtCoords(gridCoords.x, gridCoords.y);
            if (pointAt) {
                draggingCommandIndex = pointAt.cmdIdx;
                draggingPointIndex = pointAt.ptIdx;
                isDrawing = true;
                return;
            }

            isDrawing = true;

            if (currentTool === 'line') {
                if (!startPoint) {
                    startPoint = gridCoords;
                } else {
                    commands.push([1, startPoint.x, startPoint.y, gridCoords.x, gridCoords.y]);
                    startPoint = null;
                    updateCommandList();
                    redraw();
                }
            } 
            else if (currentTool === 'dot') {
                commands.push([2, gridCoords.x, gridCoords.y]);
                updateCommandList();
                redraw();
            } 
            else if (currentTool === 'arc') {
                if (!startPoint) {
                    startPoint = gridCoords;
                } else if (!arcCenter) {
                    arcCenter = gridCoords;
                } else {
                    commands.push([3, startPoint.x, startPoint.y, arcCenter.x, arcCenter.y, gridCoords.x, gridCoords.y]);
                    arcCenter = null;
                    startPoint = null;
                    updateCommandList();
                    redraw();
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            const gridCoords = screenToGrid(x, y);

            hoveredPoint = gridCoords;

            if (isDrawing && draggingCommandIndex !== null && draggingPointIndex !== null) {
                const cmd = commands[draggingCommandIndex];
                const [type, ...args] = cmd;
                
                if (isInCircle(gridCoords.x, gridCoords.y)) {
                    const argsCopy = [...args];
                    const ptIdx = draggingPointIndex * 2;
                    argsCopy[ptIdx] = gridCoords.x;
                    argsCopy[ptIdx + 1] = gridCoords.y;
                    commands[draggingCommandIndex] = [type, ...argsCopy];
                    updateCommandList();
                    redraw();
                }
                return;
            }

            if (!isInCircle(gridCoords.x, gridCoords.y)) {
                currentPreview = null;
                redraw();
                return;
            }

            if (currentTool === 'line' && startPoint) {
                currentPreview = [1, startPoint.x, startPoint.y, gridCoords.x, gridCoords.y];
            } 
            else if (currentTool === 'arc') {
                if (startPoint && arcCenter) {
                    currentPreview = [3, startPoint.x, startPoint.y, arcCenter.x, arcCenter.y, gridCoords.x, gridCoords.y];
                }
            } else {
                currentPreview = null;
            }

            redraw();
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
            draggingCommandIndex = null;
            draggingPointIndex = null;
        });

        document.getElementById('lineBtn').addEventListener('click', function() {
            currentTool = 'line';
            startPoint = null;
            arcCenter = null;
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            redraw();
        });

        document.getElementById('dotBtn').addEventListener('click', function() {
            currentTool = 'dot';
            startPoint = null;
            arcCenter = null;
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            redraw();
        });

        document.getElementById('arcBtn').addEventListener('click', function() {
            currentTool = 'arc';
            startPoint = null;
            arcCenter = null;
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            redraw();
        });

        document.getElementById('undoBtn').addEventListener('click', () => {
            if (commands.length > 0) {
                commands.pop();
                updateCommandList();
                redraw();
            }
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            if (confirm('Clear all commands?')) {
                commands = [];
                startPoint = null;
                arcCenter = null;
                updateCommandList();
                redraw();
            }
        });

        function copyToClipboard() {
            const exportBox = document.getElementById('exportCode');
            if (exportBox.value) {
                exportBox.select();
                document.execCommand('copy');
                alert('‚úÖ Array copied to clipboard!');
            }
        }

        function downloadAsText() {
            const exportBox = document.getElementById('exportCode');
            if (exportBox.value) {
                const element = document.createElement('a');
                element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(exportBox.value));
                element.setAttribute('download', 'vex_iq_commands.txt');
                element.style.display = 'none';
                document.body.appendChild(element);
                element.click();
                document.body.removeChild(element);
            }
        }

        resizeCanvas();
    </script>
</body>
</html>